<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="Process Scheduling Solver" content="width=device-width, initial-scale=1.0">
    <title>Process Scheduling Solver</title>
</head>

<body>
    <div class="Maincontainer">
        <div class="Incontainer">
            <h1 style="margin-bottom: 14px;">Input</h1>
            <label for="">Algorithm</label><br>
            <select name="A" id="Algorithm">
                <option value="FCFS">First Come First Serve, FCFS</option>
                <option value="SJF">Shortest Job First, SJF (non-preemptive)</option>
                <option value="SRTF">Shortest Remaining Time First, SRTF</option>
                <option value="RR">Round Robin, RR</option>
                <option value="NPP">Priority (non-preemptive)</option>
                <option value="PP">Priority (preemptive)</option>
            </select><br><br>

            <label for="arrivalTimes">Arrival Times</label><br>
            <input type="text" id="arrivalTimes" placeholder="e.g. 0 2 4 6 8"><br><br>

            <label for="burstTimes">Burst Times</label><br>
            <input type="text" id="burstTimes" placeholder="e.g. 2 4 6 8 10"><br><br>

            <div id="quantumField" style="display: none;">
                <label for="quantum">Time Quantum</label><br>
                <input type="number" id="quantum" placeholder="e.g. 4" min="1"><br><br>
            </div>


            <div id="priorityField" style="display: none;">
                <label for="priorities">Priorities</label><br>
                <input type="text" id="priorities" placeholder="Lower #= higher priority"><br><br>
            </div>

            <div style="display: flex; justify-content: center;">
                <button id="solveBtn">Solve</button>
            </div>
        </div>

        <div style="margin-bottom: 30px;" class="Outcontainer" id="Outcontainer">
            <h1 style="text-align: left;">Output</h1>
            <p style="color: #666; padding-top: 10px;">Gantt chart and table will be shown here</p>
        </div>
    </div>
</body>
<footer class="footer">
    <a class="github" href="https://github.com/Kaze-06/Process-Scheduling-Solver.git" target="_blank">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 438.549 438.549">
            <path
                d="M409.132 114.573c-19.608-33.596-46.205-60.194-79.798-79.8-33.598-19.607-70.277-29.408-110.063-29.408-39.781 0-76.472 9.804-110.063 29.408-33.596 19.605-60.192 46.204-79.8 79.8C9.803 148.168 0 184.854 0 224.63c0 47.78 13.94 90.745 41.827 128.906 27.884 38.164 63.906 64.572 108.063 79.227 5.14.954 8.945.283 11.419-1.996 2.475-2.282 3.711-5.14 3.711-8.562 0-.571-.049-5.708-.144-15.417a2549.81 2549.81 0 
    0 1-.144-25.406l-6.567 1.136c-4.187.767-9.469 1.092-15.846 1-6.374-.089-12.991-.757-19.842-1.999-6.854-1.231-13.229-4.086-19.13-8.559-5.898-4.473-10.085-10.328-12.56-17.556l-2.855-6.57c-1.903-4.374-4.899-9.233-8.992-14.559-4.093-5.331-8.232-8.945-12.419-10.848l-1.999-1.431c-1.332-.951-2.568-2.098-3.711-3.429-1.142-1.331-1.997-2.663-2.568-3.997-.572-1.335-.098-2.43 1.427-3.289 1.525-.859 4.281-1.276 8.28-1.276l5.708.853c3.807.763 8.516 3.042 14.133 6.851 
    5.614 3.806 10.229 8.754 13.846 14.842 4.38 7.806 9.657 13.754 15.846 17.847 6.184 4.093 12.419 6.136 18.699 6.136 6.28 0 11.704-.476 16.274-1.423 4.565-.952 8.848-2.383 
    12.847-4.285 1.713-12.758 6.377-22.559 13.988-29.41-10.848-1.14-20.601-2.857-29.264-5.14-8.658-2.286-17.605-5.996-26.835-11.14-9.235-5.137-16.896-11.516-22.985-19.126-6.09-7.614-11.088-17.61-14.987-29.979-3.901-12.374-5.852-26.648-5.852-42.826 0-23.035 7.52-42.637 22.557-58.817-7.044-17.318-6.379-36.732 1.997-58.24 5.52-1.715 13.706-.428 24.554 3.853 10.85 4.283 18.794 7.952 23.84 10.994 5.046 3.041 9.089 5.618 12.135 7.708 17.705-4.947 35.976-7.421 
    54.818-7.421s37.117 2.474 54.823 7.421l10.849-6.849c7.419-4.57 16.18-8.758 26.262-12.565 10.088-3.805 17.802-4.853 23.134-3.138 8.562 21.509 9.325 40.922 2.279 58.24 15.036 16.18 22.559 35.787 22.559 58.817 0 16.178-1.958 30.497-5.853
     42.966-3.9 12.471-8.941 22.457-15.125 29.979-6.191 7.521-13.901 13.85-23.131 18.986-9.232 5.14-18.182 8.85-26.84 11.136-8.662 2.286-18.415 4.004-29.263 5.146 9.894 8.562 14.842 22.077 14.842 40.539v60.237c0 3.422 1.19 6.279 3.572 8.562 2.379 2.279 6.136 2.95 11.276 1.995 44.163-14.653 80.185-41.062 108.068-79.226 27.88-38.161 41.825-81.126 41.825-128.906-.01-39.771-9.818-76.454-29.414-110.049z">
            </path>
        </svg>
        GitHub
    </a>
</footer>


<script>

    // ------------ Toggle visibility of priority input based on selected algorithm ----------------
    document.getElementById("Algorithm").addEventListener("change", function () {
        const selected = this.value;
        const priorityField = document.getElementById("priorityField");
        const quantumField = document.getElementById("quantumField");

        // ---------------- Show priority field only for Priority algorithms ----------------
        if (selected === "PP" || selected === "NPP") {
            priorityField.style.display = "block";
        } else {
            priorityField.style.display = "none";
            document.getElementById("priorities").value = ""; // clear input
        }

        // Show quantum field only for Round Robin
        if (selected === "RR") {
            quantumField.style.display = "block";
        } else {
            quantumField.style.display = "none";
            document.getElementById("quantum").value = ""; // clear input
        }
    });


    document.getElementById("solveBtn").addEventListener("click", function () {
        const selectedAlgorithm = document.getElementById("Algorithm").value;

        // ---------------- Get user inputs and convert to arrays of numbers ----------------
        const arrivalInput = document.getElementById("arrivalTimes").value.trim();
        const burstInput = document.getElementById("burstTimes").value.trim();
        const priorityInput = document.getElementById("priorities").value.trim();

        const arrivalTimes = arrivalInput.split(" ").map(Number);
        const burstTimes = burstInput.split(" ").map(Number);
        const priorities = priorityInput.split(" ").map(Number);

        // ---------- 1. Input Validation -------------
        if (
            arrivalTimes.length !== burstTimes.length ||
            arrivalTimes.some(isNaN) ||
            burstTimes.some(isNaN) ||
            arrivalInput == "" ||
            burstInput == "" ||
            burstTimes.some(bt => bt <= 0)

        ) {
            alert("Invalid input. Please enter numbers with equal length for arrival and burst times.");
            return;
            //----------- Validation for Priority & Non-priority & Round Robin ----------------
        } else if (
            (selectedAlgorithm === "PP" || selectedAlgorithm === "NPP") &&
            (priorities.length !== burstTimes.length || priorities.some(isNaN))
        ) {
            alert("Invalid priority input. Please enter a valid priority for each process.");
            return;
        }


        // ---------- 2. Initialize Process Objects ----------
        processes = arrivalTimes.map((arrival, index) => ({
            name: String.fromCharCode(65 + index), // A, B, C...
            arrivalTime: arrival,
            burstTime: burstTimes[index],
            priority: priorities[index],
            startTime: undefined,
            completionTime: undefined,
            waitingTime: undefined,
            turnaroundTime: undefined
        }));


        // ---------------- We'll need a timeline if using preemptive algorithm (e.g. SRTF), initialize here ----------------
        let timeline = [];

        // ---------- 3. Scheduling Algorithms ----------
        if (selectedAlgorithm === "FCFS") {
            // Non-preemptive FCFS
            processes.sort((a, b) => a.arrivalTime - b.arrivalTime);

            let currentTime = 0;
            processes.forEach(proc => {
                // wait for arrival if CPU is idle
                if (currentTime < proc.arrivalTime) {
                    currentTime = proc.arrivalTime;
                }
                proc.startTime = currentTime;
                proc.completionTime = currentTime + proc.burstTime;
                proc.turnaroundTime = proc.completionTime - proc.arrivalTime;
                proc.waitingTime = proc.turnaroundTime - proc.burstTime;
                currentTime = proc.completionTime;
            });

            // For FCFS we can build a simple timeline where each process runs in one block
            timeline = processes.map(proc => ({
                name: proc.name,
                startTime: proc.startTime,
                endTime: proc.completionTime
            }));

        } else if (selectedAlgorithm === "SJF") {
            // Non-preemptive Shortest Job First
            let n = processes.length;
            let isCompleted = new Array(n).fill(false);
            let completed = 0;
            let currentTime = 0;

            while (completed < n) {
                let idx = -1;
                let minBurst = Infinity;

                for (let i = 0; i < n; i++) {
                    if (!isCompleted[i] &&
                        processes[i].arrivalTime <= currentTime &&
                        processes[i].burstTime < minBurst) {
                        minBurst = processes[i].burstTime;
                        idx = i;
                    }
                }

                if (idx === -1) {
                    currentTime++; // CPU idle
                } else {
                    let proc = processes[idx];
                    proc.startTime = currentTime;
                    proc.completionTime = currentTime + proc.burstTime;
                    proc.turnaroundTime = proc.completionTime - proc.arrivalTime;
                    proc.waitingTime = proc.turnaroundTime - proc.burstTime;

                    // Push correct timeline segment
                    timeline.push({
                        name: proc.name,
                        startTime: proc.startTime,
                        endTime: proc.completionTime
                    });

                    currentTime = proc.completionTime;
                    isCompleted[idx] = true;
                    completed++;
                }
            }
        }
        else if (selectedAlgorithm === "SRTF") {
            // Preemptive Shortest Remaining Time First
            let n = processes.length;
            let remainingTimes = processes.map(p => p.burstTime);
            let isCompleted = new Array(n).fill(false);
            let completed = 0;
            let currentTime = 0;
            let lastProcessIndex = -1; // to track switching
            // timeline already declared above

            while (completed < n) {
                let idx = -1;
                let minTime = Infinity;

                for (let i = 0; i < n; i++) {
                    if (!isCompleted[i] &&
                        processes[i].arrivalTime <= currentTime &&
                        remainingTimes[i] > 0 &&
                        remainingTimes[i] < minTime) {
                        minTime = remainingTimes[i];
                        idx = i;
                    }
                }

                if (idx === -1) {
                    // No process ready: CPU idle for this time unit
                    currentTime++;
                    continue;
                }

                // If new process starts (or switching to another), push a new timeline segment
                if (lastProcessIndex !== idx) {
                    timeline.push({
                        name: processes[idx].name,
                        startTime: currentTime,
                        endTime: null
                    });
                    lastProcessIndex = idx;
                }

                // Execute one unit of burst
                remainingTimes[idx]--;
                currentTime++;

                // Update endTime of the latest timeline segment
                timeline[timeline.length - 1].endTime = currentTime;

                if (remainingTimes[idx] === 0) {
                    // This process finishes
                    processes[idx].completionTime = currentTime;
                    processes[idx].turnaroundTime = currentTime - processes[idx].arrivalTime;
                    processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;
                    isCompleted[idx] = true;
                    completed++;
                }
            }

            // Also need to set startTime for processes properly (earliest time from timeline)
            processes.forEach(proc => {
                // find when this process first appears in timeline
                const seg = timeline.find(t => t.name === proc.name);
                if (seg) {
                    proc.startTime = seg.startTime;
                }
                // completionTime, waitingTime, etc, already set
            });

        } else if (selectedAlgorithm === "NPP") {
            // Non-Preemptive Priority


            let n = processes.length;
            let isCompleted = new Array(n).fill(false);
            let completed = 0;
            let currentTime = 0;

            while (completed < n) {
                let idx = -1;
                let highestPriority = Infinity;

                for (let i = 0; i < n; i++) {
                    if (!isCompleted[i] &&
                        processes[i].arrivalTime <= currentTime &&
                        processes[i].priority < highestPriority) {
                        highestPriority = processes[i].priority;
                        idx = i;
                    }
                }

                if (idx === -1) {
                    currentTime++; // idle
                } else {
                    let proc = processes[idx];
                    proc.startTime = currentTime;
                    proc.completionTime = currentTime + proc.burstTime;
                    proc.turnaroundTime = proc.completionTime - proc.arrivalTime;
                    proc.waitingTime = proc.turnaroundTime - proc.burstTime;

                    timeline.push({
                        name: proc.name,
                        startTime: proc.startTime,
                        endTime: proc.completionTime
                    });

                    currentTime = proc.completionTime;
                    isCompleted[idx] = true;
                    completed++;
                }
            }
        }

        else if (selectedAlgorithm === "PP") {
            // Preemptive Priority Scheduling

            let n = processes.length;
            let remainingTimes = processes.map(p => p.burstTime);
            let isCompleted = new Array(n).fill(false);
            let completed = 0;
            let currentTime = 0;
            let lastProcessIndex = -1;

            while (completed < n) {
                let idx = -1;
                let highestPriority = Infinity;

                for (let i = 0; i < n; i++) {
                    if (!isCompleted[i] &&
                        processes[i].arrivalTime <= currentTime &&
                        processes[i].priority < highestPriority &&
                        remainingTimes[i] > 0) {
                        highestPriority = processes[i].priority;
                        idx = i;
                    }
                }

                if (idx === -1) {
                    currentTime++;
                    continue;
                }

                if (lastProcessIndex !== idx) {
                    timeline.push({
                        name: processes[idx].name,
                        startTime: currentTime,
                        endTime: null
                    });
                    lastProcessIndex = idx;
                }

                remainingTimes[idx]--;
                currentTime++;

                timeline[timeline.length - 1].endTime = currentTime;

                if (remainingTimes[idx] === 0) {
                    processes[idx].completionTime = currentTime;
                    processes[idx].turnaroundTime = currentTime - processes[idx].arrivalTime;
                    processes[idx].waitingTime = processes[idx].turnaroundTime - processes[idx].burstTime;
                    isCompleted[idx] = true;
                    completed++;
                }
            }

            processes.forEach(proc => {
                const seg = timeline.find(t => t.name === proc.name);
                if (seg) {
                    proc.startTime = seg.startTime;
                }
            });
        }

        else if (selectedAlgorithm === "RR") {
            const quantum = parseInt(document.getElementById("quantum").value);
            if (isNaN(quantum) || quantum <= 0) {
                alert("Please enter a valid time quantum.");
                return;
            }


            let n = processes.length;
            let queue = [];
            let remainingTimes = processes.map(p => p.burstTime);
            let isInQueue = new Array(n).fill(false);

            // Assign an index to each process for tracking
            processes.forEach((p, i) => {
                p.index = i;
            });

            // Start simulation from the first arrival time
            let currentTime = Math.min(...processes.map(p => p.arrivalTime));

            // Initially add all processes that have already arrived
            for (let i = 0; i < n; i++) {
                if (processes[i].arrivalTime <= currentTime) {
                    queue.push(processes[i]);
                    isInQueue[i] = true;
                }
            }

            while (queue.length > 0) {
                let proc = queue.shift();
                let idx = proc.index;

                // First time execution
                if (proc.startTime === undefined) {
                    proc.startTime = currentTime;
                }

                let execTime = Math.min(quantum, remainingTimes[idx]);

                // Add to timeline
                timeline.push({
                    name: proc.name,
                    startTime: currentTime,
                    endTime: currentTime + execTime
                });

                currentTime += execTime;
                remainingTimes[idx] -= execTime;

                // Add newly arrived processes to queue
                for (let i = 0; i < n; i++) {
                    if (!isInQueue[i] && processes[i].arrivalTime <= currentTime && remainingTimes[i] > 0) {
                        queue.push(processes[i]);
                        isInQueue[i] = true;
                    }
                }

                // Requeue current process if it's not done
                if (remainingTimes[idx] > 0) {
                    queue.push(proc);
                } else {
                    // Process completed
                    proc.completionTime = currentTime;
                    proc.turnaroundTime = proc.completionTime - proc.arrivalTime;
                    proc.waitingTime = proc.turnaroundTime - proc.burstTime;
                }

                // If queue is empty but there are still processes left, advance time
                if (queue.length === 0) {
                    for (let i = 0; i < n; i++) {
                        if (remainingTimes[i] > 0 && processes[i].arrivalTime > currentTime) {
                            currentTime = processes[i].arrivalTime;
                            queue.push(processes[i]);
                            isInQueue[i] = true;
                            break;
                        }
                    }
                }
            }

            // Ensure each process has its earliest startTime from the timeline
            processes.forEach(proc => {
                const seg = timeline.find(t => t.name === proc.name);
                if (seg) {
                    proc.startTime = seg.startTime;
                }
            });
        }



        // ---------- 4. Average Calculations ----------
        const totalWaitingTime = processes.reduce((sum, p) => sum + p.waitingTime, 0);
        const totalTurnaroundTime = processes.reduce((sum, p) => sum + p.turnaroundTime, 0);

        const averageWaitingTime = (totalWaitingTime / processes.length).toFixed(2);
        const averageTurnaroundTime = (totalTurnaroundTime / processes.length).toFixed(2);

        // ---------- 5. Output Result HTML ----------
        let resultHTML = ``;

        // ---------- Gantt Chart Title ----------
        resultHTML += `
         <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
         <h1 style="margin: 0;">Output</h1>
         <p style="padding: 10px; background-color: #EDF4FF; border-radius: 5px; color: #666; margin: 0;">
         <strong>${selectedAlgorithm}</strong>
         </p>
         </div>`;
        resultHTML += `<h3 style="text-align: center; color: #424242;">Order of processing</h3>`;

        // ---------- Gantt Chart ----------
        resultHTML += `<div style="display: flex; justify-content: center; align-items: center; margin-top: 6px; margin-bottom: 3px; flex-wrap: wrap;">`;

        // ---------- Insert Idle Segments if Needed ----------
        let finalTimeline = [];
        if (timeline.length > 0) {
            // Sort timeline just in case
            timeline.sort((a, b) => a.startTime - b.startTime);

            for (let i = 0; i < timeline.length; i++) {
                const current = timeline[i];

                if (i === 0) {
                    // If first process doesn't start at time 0, add initial idle
                    if (current.startTime > 0) {
                        finalTimeline.push({
                            name: "Idle",
                            startTime: 0,
                            endTime: current.startTime
                        });
                    }
                } else {
                    const previous = timeline[i - 1];
                    if (current.startTime > previous.endTime) {
                        finalTimeline.push({
                            name: "Idle",
                            startTime: previous.endTime,
                            endTime: current.startTime
                        });
                    }
                }

                finalTimeline.push(current);
            }
        } else {
            finalTimeline = timeline;
        }

        finalTimeline.forEach(segment => {
            resultHTML += `
        <div style="
            background-color: ${segment.name === "Idle" ? "#FFECEC" : "#EDF4FF"};
            border: 1px solid ${segment.name === "Idle" ? "#FF5C5C" : "#009BFF"};
            padding: 10px;
            width: 60px;
            text-align: center;
            margin: 0px;
            color: #424242;
            font-size: 0.9rem;
        ">
            ${segment.name}
        </div>
    `;
        });

        resultHTML += `</div>`;

        // ---------- Time Markers ----------
        resultHTML += `<div style="display: flex; justify-content: center; margin-bottom: 25px;">`;
        finalTimeline.forEach(segment => {
            resultHTML += `
        <div style="width: 60px; text-align: left;">
            <small>${segment.startTime}</small>
        </div>
    `;
        });
        if (finalTimeline.length > 0) {
            resultHTML += `
        <div style="text-align: left;">
            <small>${finalTimeline[finalTimeline.length - 1].endTime}</small>
        </div>
    `;
        }

        resultHTML += `</div>`;

        // ---------- Process Table ----------
        resultHTML += `<div class="table-wrapper"><table>`;
        resultHTML += `
    <tr>
        <th>Job</th>
        <th>Arrival Time</th>
        <th>Burst Time</th>
        ${["PP", "NPP"].includes(selectedAlgorithm) ? "<th>Priority</th>" : ""}
        <th>Completion Time</th>
        <th>Turnaround Time</th>
        <th>Waiting Time</th>
    </tr>
`;

        processes.forEach(p => {
            resultHTML += `
        <tr>
            <td>${p.name}</td>
            <td>${p.arrivalTime}</td>
            <td>${p.burstTime}</td>
            ${["PP", "NPP"].includes(selectedAlgorithm) ? `<td>${p.priority}</td>` : ""}
            <td>${p.completionTime}</td>
            <td>${p.arrivalTime} - ${p.completionTime} = <strong>${p.turnaroundTime}</strong></td>
            <td>${p.burstTime} - ${p.turnaroundTime} = <strong>${p.waitingTime}</strong></td>
        </tr>
    `;
        });

        // ---------- Average Row ----------
        resultHTML += `
    <tr>
        <td colspan="${["PP", "NPP"].includes(selectedAlgorithm) ? 5 : 4}" style="padding: 10px; text-align: right;"><strong>Average</strong></td>
        <td>${totalTurnaroundTime} / ${processes.length} = <strong>${averageTurnaroundTime}</strong></td>
        <td>${totalWaitingTime} / ${processes.length} = <strong>${averageWaitingTime}</strong></td>
    </tr>
`;

        // ---------- CPU Utilization ----------
        const definedStartTimes = processes.map(p => p.startTime).filter(st => st !== undefined);
        const definedCompletionTimes = processes.map(p => p.completionTime).filter(ct => ct !== undefined);

        if (definedStartTimes.length > 0 && definedCompletionTimes.length > 0) {
            const firstStartTime = Math.min(...definedStartTimes);
            const lastCompletionTime = Math.max(...definedCompletionTimes);
            const totalBurstTime = processes.reduce((sum, p) => sum + p.burstTime, 0);
            const totalTimeElapsed = lastCompletionTime - firstStartTime;
            const cpuUtilization = totalTimeElapsed > 0
                ? ((totalBurstTime / totalTimeElapsed) * 100).toFixed(2)
                : "100.00";

            resultHTML += `
        <tr>
            <td colspan="7"><strong>CPU Utilization</strong>: (${totalBurstTime} / ${totalTimeElapsed}) × 100 = <strong>${cpuUtilization}%</strong></td>
        </tr>
    `;
        } else {
            resultHTML += `
        <tr>
            <td colspan="7"><strong>CPU Utilization</strong>: N/A</td>
        </tr>
    `;
        }

        resultHTML += `</table></div>`;

        // ---------- Inject into Outcontainer ----------
        document.getElementById("Outcontainer").innerHTML = resultHTML;


    });
    // ---------- Animation drip sa Button ----------
    document.querySelectorAll("button").forEach(button => {
        button.addEventListener("click", function (e) {
            const circle = document.createElement("span");
            circle.classList.add("ripple");

            const rect = button.getBoundingClientRect();
            const size = Math.max(button.clientWidth, button.clientHeight);
            circle.style.width = circle.style.height = `${size}px`;
            circle.style.left = `${e.clientX - rect.left - size / 2}px`;
            circle.style.top = `${e.clientY - rect.top - size / 2}px`;

            button.appendChild(circle);

            setTimeout(() => {
                circle.remove();
            }, 600); // matches animation duration
        });
    });
</script>

<style>
    .footer {
        position: fixed;
        bottom: 20px;
        left: 20px;
        z-index: 999;
    }

    .footer .github {
        display: flex;
        align-items: center;
        gap: 6px;
        color: black;
        text-decoration: none;
        font-weight: 500;
        transition: color 0.3s ease;
    }

    .footer .github:hover {
        color: #007bff;
        /* Change this if you prefer a different hover color */
    }

    .footer .github svg {
        fill: currentColor;
        transition: fill 0.3s ease;
    }

    /* === Reset and Base Styles === */
    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    html {
        font-family: "Helvetica", sans-serif;
        font-size: 16px;
    }

    body {
        background-color: #f5f5f5;
        padding: 20px;
    }

    /* === Layout === */
    .Maincontainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: flex-start;
        gap: 25px;
    }

    .Incontainer,
    .Outcontainer {
        padding: 30px;
        border: 1px solid #ddd;
        border-radius: 15px;
        background-color: #ffffff;
        box-shadow: 0 2px 8px rgba(148, 148, 148, 0.2);
        width: 100%;
    }

    .Incontainer form {
        display: flex;
        flex-direction: column;
        gap: 16px;
    }

    /* === Form Elements === */
    select,
    input {
        width: 100%;
        padding: 10px 12px;
        font-size: 14px;
        border: 1px solid #ccc;
        border-radius: 6px;
        background-color: #ffffff;
        color: #333;
        outline: none;
        transition: background-color 0.3s, border-color 0.3s;
    }

    select:hover,
    input:hover {
        background-color: #f9f9f9;
        border-color: #a7a7a7;
    }

    select:focus,
    input:focus {
        border-color: #2684FF;
        box-shadow: 0 0 6px rgba(0, 123, 255, 0.3);
    }

    /* === Buttons === */
    button {
        width: 100%;
        max-width: 150px;
        padding: 10px 0;
        font-size: 16px;
        color: #fff;
        background-color: #2684FF;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
        align-self: flex-start;
        position: relative;
        overflow: hidden;

    }

    button:hover {
        background-color: #005BFF;
    }

    /* Ripple effect span */
    button .ripple {
        position: absolute;
        border-radius: 50%;
        transform: scale(0);
        animation: ripple-animation 0.6s linear;
        background-color: rgba(255, 255, 255, 0.7);
        pointer-events: none;
    }

    @keyframes ripple-animation {
        to {
            transform: scale(4);
            opacity: 0;
        }
    }

    /* === Table Wrapper === */
    .table-wrapper {
        width: 100%;
        overflow-x: auto;
    }

    table {
        width: 100%;
        min-width: 700px;
        border-collapse: collapse;
        text-align: center;
    }

    table th,
    table td {
        padding: 10px 12px;
        border: 1px solid #ccc;
    }

    table th {
        background-color: #f7f7f7;
    }

    /* === Media Queries === */

    /* Mobile (≤ 480px) */
    @media only screen and (max-width: 480px) {
        html {
            font-size: 12px;
        }

        .Maincontainer {
            flex-direction: column;
            gap: 10px;
        }

        .Incontainer,
        .Outcontainer {
            width: 100%;
            max-width: 100%;
            padding: 20px;
            font-size: 12px;
        }

        table {
            font-size: 12px;
            min-width: 600px;
        }

        .table-wrapper {
            margin-bottom: 20px;
        }

        select,
        input {
            font-size: 10px;
            padding: 8px 10px;
        }

        button {
            font-size: 12px;
            width: 80px;
        }
    }

    /* Tablet (481px–900px) */
    @media only screen and (min-width: 481px) and (max-width: 1098px) {
        html {
            font-size: 14px;
        }

        .Maincontainer {
            flex-direction: column;
            gap: 20px;
        }

        .Incontainer,
        .Outcontainer {
            width: 100%;
            max-width: 100%;
        }

        select,
        input {
            font-size: 14px;
            margin-top: 6px;
            margin-bottom: 8px;
        }

        button {
            font-size: 15px;
        }

        .github {
            padding-left: 8%;
        }
    }

    /* PC/Laptop (≥ 901px) */
    @media only screen and (min-width: 1098px) {
        html {
            font-size: 16px;
        }

        .Maincontainer {
            flex-direction: row;
            /* ✅ Side-by-side only on desktop */
            align-items: flex-start;
        }

        .Incontainer {
            flex: 1 1 350px;
            max-width: 400px;
            margin-bottom: 30px;
        }

        .Outcontainer {
            flex: 2 1 600px;
            max-width: 900px;
        }

        .github {
            padding-left: 6%;
        }

    }
</style>


</html>